import React, { useState, useEffect } from 'react';
import { Layers, ArrowDown, Image as ImageIcon, CheckCircle, Code, Calculator, Sigma } from 'lucide-react';

// --- Components ---

// 코드 블록 컴포넌트
const CodeBlock = ({ title, code }) => (
  <div className="mt-6 bg-slate-50 rounded-lg border border-slate-200 overflow-hidden text-sm font-mono">
    <div className="bg-slate-100 px-4 py-2 border-b border-slate-200 flex items-center gap-2 text-slate-600">
      <Code className="w-4 h-4" />
      <span className="font-semibold text-xs uppercase">{title}</span>
    </div>
    <div className="p-4 overflow-x-auto text-slate-800 leading-relaxed whitespace-pre">
      {code}
    </div>
  </div>
);

// 수학 공식 컴포넌트
const MathBlock = ({ title, children }) => (
  <div className="mt-4 mb-2 bg-indigo-50/50 p-4 rounded-lg border border-indigo-100 text-slate-700">
    <div className="flex items-center gap-2 mb-2 text-indigo-800 font-semibold text-xs uppercase">
      <Calculator className="w-4 h-4" />
      <span>{title}</span>
    </div>
    <div className="font-serif text-lg text-center py-2">
      {children}
    </div>
  </div>
);

const Section = ({ title, children }) => (
  <div className="py-16 border-b border-slate-200 last:border-0">
    <h2 className="text-3xl font-bold mb-6 text-indigo-700 flex items-center gap-2">
      {title}
    </h2>
    <div className="text-lg leading-relaxed text-slate-700 space-y-4">
      {children}
    </div>
  </div>
);

const ConvVisualizer = () => {
  return (
    <div className="bg-white p-6 rounded-xl border border-slate-200 shadow-lg relative overflow-hidden">
      <h3 className="text-center text-slate-500 mb-4 text-sm font-semibold uppercase tracking-wider">Convolution Operation</h3>
      <div className="flex items-center justify-center gap-8">
        {/* Input Image Grid */}
        <div className="relative grid grid-cols-5 gap-1 p-2 bg-slate-100 rounded border border-slate-300">
          {[...Array(25)].map((_, i) => (
            <div key={i} className={`w-6 h-6 rounded-sm text-[8px] flex items-center justify-center font-medium ${
              [6,7,8,11,12,13,16,17,18].includes(i) ? 'bg-indigo-100 text-indigo-700' : 'bg-white text-slate-400 border border-slate-100'
            }`}>
              {Math.floor(Math.random() * 9)}
            </div>
          ))}
          {/* Moving Filter */}
          <div className="absolute top-2 left-2 w-[84px] h-[84px] border-2 border-yellow-500 rounded bg-yellow-400/20 flex items-center justify-center">
            <span className="text-yellow-700 text-xs font-bold bg-white/90 px-1 rounded shadow-sm">Filter</span>
          </div>
        </div>

        <ArrowDown className="rotate-[-90deg] text-slate-400" />

        {/* Feature Map */}
        <div className="grid grid-cols-3 gap-1 p-2 bg-slate-100 rounded border border-slate-300">
           {[...Array(9)].map((_, i) => (
            <div key={i} className={`w-8 h-8 rounded-sm flex items-center justify-center border border-slate-200 font-bold ${i===4 ? 'bg-yellow-500 text-white shadow-md' : 'bg-white text-slate-500'}`}>
              {i===4 ? '9' : Math.floor(Math.random() * 5)}
            </div>
          ))}
        </div>
      </div>
      <p className="mt-6 text-sm text-center text-slate-600 bg-slate-50 py-2 rounded">필터(노란색)가 이미지를 순회하며 특징(Feature Map)을 추출합니다.</p>
    </div>
  );
};

const PoolingVisualizer = () => {
  return (
    <div className="bg-white p-6 rounded-xl border border-slate-200 shadow-lg">
      <h3 className="text-center text-slate-500 mb-4 text-sm font-semibold uppercase tracking-wider">Max Pooling (2x2)</h3>
      <div className="flex flex-col items-center gap-4">
        {/* 4x4 Input */}
        <div className="grid grid-cols-4 gap-1 p-2 bg-slate-100 rounded border border-slate-300">
           {[1,0,2,3, 4,6,6,8, 3,1,1,0, 1,2,2,4].map((val, i) => (
             <div key={i} className={`w-8 h-8 flex items-center justify-center rounded-sm text-sm font-medium
               ${[5,6,9,10].includes(i) ? 'bg-red-100 text-red-600 border border-red-200' : 'bg-white text-slate-400 border border-slate-100'}
             `}>
               {val}
             </div>
           ))}
        </div>
        
        <ArrowDown className="text-slate-400" />

        {/* 2x2 Output */}
        <div className="grid grid-cols-2 gap-1 p-2 bg-slate-100 rounded border border-slate-300">
           {[6, 8, 3, 4].map((val, i) => (
             <div key={i} className={`w-12 h-12 flex items-center justify-center rounded-sm font-bold text-lg shadow-sm
                ${i===0 ? 'bg-red-500 text-white' : 'bg-white text-slate-600 border border-slate-200'}
             `}>
               {val}
             </div>
           ))}
        </div>
      </div>
       <p className="mt-6 text-sm text-center text-slate-600 bg-slate-50 py-2 rounded">영역 내 가장 큰 값(Max)만 남기고 크기를 줄입니다.</p>
    </div>
  );
};

const ArchitectureVisualizer = () => {
  return (
    <div className="bg-white p-6 rounded-xl border border-slate-200 shadow-lg flex flex-col items-center justify-center h-full">
      <div className="flex items-center gap-2 mb-8 scale-110">
        <div className="w-12 h-12 bg-blue-600 rounded flex items-center justify-center text-white font-bold text-xs shadow-md">Input</div>
        <div className="h-1 w-4 bg-slate-300"></div>
        <div className="flex flex-col gap-1">
            <div className="w-8 h-8 bg-indigo-500 rounded shadow-sm"></div>
            <div className="w-8 h-8 bg-indigo-500 rounded shadow-sm"></div>
            <div className="w-8 h-8 bg-indigo-500 rounded shadow-sm"></div>
        </div>
        <div className="h-1 w-4 bg-slate-300"></div>
        <div className="flex flex-col gap-1">
            <div className="w-6 h-6 bg-red-500 rounded shadow-sm"></div>
            <div className="w-6 h-6 bg-red-500 rounded shadow-sm"></div>
        </div>
        <div className="h-1 w-4 bg-slate-300"></div>
         <div className="flex flex-col gap-0.5">
            {[...Array(6)].map((_,i) => <div key={i} className="w-2 h-2 bg-green-500 rounded-full"></div>)}
        </div>
         <div className="h-1 w-4 bg-slate-300"></div>
         <div className="w-12 h-8 bg-slate-800 text-white rounded flex items-center justify-center font-bold text-xs shadow-md">Class</div>
      </div>
      <div className="text-center text-slate-600 text-sm space-y-2 font-medium">
        <p><span className="text-blue-600">Image</span> → <span className="text-indigo-600">Conv</span> → <span className="text-red-600">Pool</span> → <span className="text-green-600">FC</span></p>
        <p className="text-slate-500 font-normal">깊어질수록 이미지는 추상화되고,<br/>필터 수는 늘어납니다.</p>
      </div>
    </div>
  );
}

const FCVisualizer = () => {
    return (
        <div className="bg-white p-6 rounded-xl border border-slate-200 shadow-lg">
            <h3 className="text-center text-slate-500 mb-4 text-sm font-semibold uppercase tracking-wider">Fully Connected Layer</h3>
            <div className="flex items-center justify-center gap-6">
                 {/* Flattened */}
                 <div className="flex flex-col gap-1 p-2 bg-slate-100 rounded border border-slate-300">
                    <span className="text-[10px] text-center text-slate-500 mb-1 font-semibold">Flatten</span>
                    {[...Array(8)].map((_, i) => (
                        <div key={i} className="w-4 h-4 bg-red-100 rounded-full border border-red-400"></div>
                    ))}
                 </div>
                 
                 {/* Connections */}
                 <div className="flex flex-col justify-center gap-1 opacity-30">
                    <div className="w-8 h-0.5 bg-slate-800 rotate-12"></div>
                    <div className="w-8 h-0.5 bg-slate-800 -rotate-12"></div>
                    <div className="w-8 h-0.5 bg-slate-800 rotate-0"></div>
                 </div>

                 {/* Classification */}
                 <div className="flex flex-col gap-4 p-4 bg-slate-50 rounded-lg border border-slate-200 min-w-[120px]">
                     <div className="flex items-center gap-3">
                         <div className="w-3 h-3 bg-slate-300 rounded-full"></div>
                         <span className="text-sm text-slate-500">Cat (10%)</span>
                     </div>
                     <div className="flex items-center gap-3 bg-white p-2 rounded border border-blue-200 shadow-sm -mx-2">
                         <div className="w-4 h-4 bg-blue-600 rounded-full shadow-[0_0_8px_rgba(37,99,235,0.5)]"></div>
                         <span className="text-sm text-blue-700 font-bold">Dog (85%)</span>
                     </div>
                     <div className="flex items-center gap-3">
                         <div className="w-3 h-3 bg-slate-300 rounded-full"></div>
                         <span className="text-sm text-slate-500">Car (5%)</span>
                     </div>
                 </div>
            </div>
            <p className="mt-6 text-sm text-center text-slate-600 bg-slate-50 py-2 rounded">특징(Feature)들을 종합하여 최종적으로 이미지를 분류합니다.</p>
        </div>
    )
}

// --- Main Application ---

export default function CNNScrollyTelling() {
  const [activeSection, setActiveSection] = useState(0);
  
  useEffect(() => {
    const handleScroll = () => {
      const sections = document.querySelectorAll('.content-section');
      sections.forEach((section, index) => {
        const rect = section.getBoundingClientRect();
        // 화면 중간쯤 왔을 때 섹션 활성화
        if (rect.top >= 0 && rect.top <= window.innerHeight / 2) {
          setActiveSection(index);
        }
      });
    };
    
    window.addEventListener('scroll', handleScroll);
    return () => window.removeEventListener('scroll', handleScroll);
  }, []);

  const sectionsData = [
    {
      id: "intro",
      title: "CNN이란 무엇인가?",
      visual: <div className="text-9xl text-indigo-100 font-black rotate-12 select-none">CNN</div>,
      content: (
        <>
          <p>
            <strong className="text-indigo-900 bg-indigo-50 px-1 rounded">CNN(Convolutional Neural Network)</strong>은 이미지 분류 분야에서 탁월한 성능을 보여주는 딥러닝 아키텍처입니다.
            동물이 시각 정보를 처리할 때 뇌가 작동하는 방식에 착안하여 만들어졌습니다.
          </p>
          <p>
            핵심 아이디어는 두 가지의 반복입니다:
          </p>
          <ul className="list-disc list-inside bg-white p-6 rounded-lg border border-slate-200 shadow-sm space-y-2">
            <li><strong className="text-indigo-600">Conv Layer (Convolution):</strong> 이미지의 특징을 추출</li>
            <li><strong className="text-red-500">Pooling Layer:</strong> 정보를 압축하고 요약</li>
          </ul>
        </>
      )
    },
    {
      id: "conv",
      title: "Convolution Layer: 특징 추출",
      visual: <ConvVisualizer />,
      content: (
        <>
          <p>
            CNN의 심장과도 같은 부분입니다. <strong className="text-yellow-600 bg-yellow-50 px-1 rounded">Filter(필터)</strong>라고 불리는 작은 윈도우가 이미지를 순회하며 특징을 잡아냅니다.
          </p>
          <p>
            이미지(입력)와 필터(가중치)의 각 요소를 곱한 뒤 모두 더하는 <strong>합성곱(Convolution)</strong> 연산을 수행합니다.
          </p>

          <MathBlock title="합성곱 연산 (Convolution)">
            Y(i,j) = ∑(X × K) + b
          </MathBlock>
          <p className="text-sm text-slate-500">
            * X: 입력 이미지, K: 필터(커널), b: 편향(Bias)
          </p>

          <CodeBlock 
            title="PyTorch Example: Conv Layer"
            code={`import torch.nn as nn

# 입력 채널: 3 (RGB), 출력 채널: 16 (필터 개수)
# 커널 크기: 3x3, 패딩: 1 (이미지 크기 유지)
conv_layer = nn.Conv2d(
    in_channels=3, 
    out_channels=16, 
    kernel_size=3, 
    padding=1
)`} 
          />
        </>
      )
    },
    {
      id: "pooling",
      title: "Pooling Layer: 압축과 요약",
      visual: <PoolingVisualizer />,
      content: (
        <>
          <p>
            특징을 추출했다면, 이제 정보를 요약할 차례입니다. 이를 <strong>Down Sampling</strong>이라고 합니다.
          </p>
          <p>
            대표적인 방법은 <strong>Max Pooling</strong>입니다. 특정 영역에서 가장 큰 값(가장 두드러진 특징)만 남기고 나머지는 버립니다.
          </p>
          
          <MathBlock title="Max Pooling">
             Y = max(Region of X)
          </MathBlock>

          <ul className="space-y-3 mt-2 bg-white p-4 rounded-lg border border-slate-200">
             <li className="flex items-start gap-3">
                <CheckCircle className="w-5 h-5 text-green-500 shrink-0 mt-0.5" />
                <span className="text-slate-700">이미지 크기가 줄어들어 연산량이 감소합니다.</span>
             </li>
             <li className="flex items-start gap-3">
                <CheckCircle className="w-5 h-5 text-green-500 shrink-0 mt-0.5" />
                <span className="text-slate-700">특징이 더욱 뚜렷해지고(Sharpen), 작은 위치 변화에 덜 민감해집니다.</span>
             </li>
          </ul>

          <CodeBlock 
            title="PyTorch Example: Pooling"
            code={`# 2x2 영역에서 가장 큰 값 추출
# Stride: 2 (2칸씩 이동 -> 크기가 절반으로 줄어듦)
pool_layer = nn.MaxPool2d(
    kernel_size=2, 
    stride=2
)`} 
          />
        </>
      )
    },
    {
      id: "deep",
      title: "Conv + Pooling의 반복",
      visual: <ArchitectureVisualizer />,
      content: (
        <>
          <p>
            이미지가 깊은 레이어(Layer)를 통과할수록 <strong>추상화(Abstraction)</strong>됩니다.
            뒤쪽 레이어로 갈수록 <strong>Filter의 개수는 늘어납니다.</strong>
          </p>
          
          <CodeBlock 
            title="PyTorch Example: Sequential Model"
            code={`# Conv -> ReLU -> Pooling 반복 구조
model = nn.Sequential(
    # Layer 1
    nn.Conv2d(3, 16, 3),  # 특징 추출
    nn.ReLU(),            # 비선형성 (활성화 함수)
    nn.MaxPool2d(2, 2),   # 압축

    # Layer 2 (채널 수 증가: 16 -> 32)
    nn.Conv2d(16, 32, 3),
    nn.ReLU(),
    nn.MaxPool2d(2, 2)
)`} 
          />
          <p className="text-sm bg-slate-100 p-4 rounded text-slate-600 border border-slate-200 mt-4">
             이미지가 작아졌기 때문에(Pooling 덕분) 더 많은 필터를 써도 연산량 부담이 적으며, 추상적인 정보일수록 찾아낼 특징이 더 다양하기 때문입니다.
          </p>
        </>
      )
    },
    {
      id: "fc",
      title: "FC Layer: 최종 분류",
      visual: <FCVisualizer />,
      content: (
        <>
           <p>
             추출과 압축을 반복하여 얻은 최종 <strong className="text-indigo-600">Feature Map</strong>은 3차원 데이터입니다.
             이를 분류하기 위해 한 줄로 쭉 폅니다(Flatten). 그리고 <strong>FC Layer (Fully Connected Layer)</strong>에 집어넣습니다.
           </p>
           
           <MathBlock title="선형 변환 (Linear Transformation)">
             Y = WX + b
           </MathBlock>
           <p className="text-sm text-slate-500 mb-4">
             * W: 가중치 행렬(Weight), X: 입력 벡터, b: 편향
           </p>

           <p>
             이곳에서 최종적으로 "이 사진은 85% 확률로 쥐(Mouse)이다"와 같은 분류(Classification) 결론을 내리게 됩니다.
           </p>

           <CodeBlock 
            title="PyTorch Example: FC Layer"
            code={`# 2D/3D 텐서를 1D 벡터로 변환
flatten = nn.Flatten()

# 분류기 (예: 입력 512개 -> 출력 10개 클래스)
fc_layer = nn.Linear(
    in_features=512, 
    out_features=10
)`} 
          />
        </>
      )
    }
  ];

  return (
    <div className="bg-slate-50 min-h-screen text-slate-800 font-sans selection:bg-indigo-100 selection:text-indigo-900">
      {/* Header */}
      <header className="fixed top-0 left-0 w-full bg-white/90 backdrop-blur-md z-50 border-b border-slate-200 shadow-sm">
        <div className="max-w-6xl mx-auto px-6 py-4 flex items-center justify-between">
            <div className="flex items-center gap-2">
                <Layers className="text-indigo-600" />
                <h1 className="font-bold text-xl tracking-tight text-slate-900">DeepDive: <span className="text-indigo-600">CNN</span></h1>
            </div>
            <div className="text-sm text-slate-500 hidden sm:block font-medium">
                Original Text by hyundodo
            </div>
        </div>
      </header>

      {/* Hero Section */}
      <section className="min-h-[60vh] flex flex-col justify-center items-center text-center px-4 pt-32 pb-16 bg-white border-b border-slate-200">
        <div className="bg-indigo-50 p-4 rounded-full mb-6 ring-1 ring-indigo-100">
            <ImageIcon className="w-12 h-12 text-indigo-600" />
        </div>
        <h1 className="text-5xl md:text-6xl font-extrabold text-slate-900 mb-6 tracking-tight">
          Convolutional<br /><span className="text-indigo-600">Neural Network</span>
        </h1>
        <p className="text-xl text-slate-600 max-w-2xl mx-auto leading-relaxed">
          이미지가 컴퓨터에게 이해되는 과정.<br/>
          필터와 풀링으로 이미지를 분해하고 해석하는 CNN의 구조를 알아보세요.
        </p>
      </section>

      {/* Main Content Grid */}
      <main className="max-w-6xl mx-auto px-4 pb-32">
        <div className="grid grid-cols-1 lg:grid-cols-2 gap-16 relative">
          
          {/* Left Column: Text Content */}
          <div className="pt-8">
            {sectionsData.map((section, index) => (
              <div key={section.id} className="content-section min-h-[50vh] flex flex-col justify-center" data-index={index}>
                <Section title={section.title} isActive={activeSection === index}>
                  {section.content}
                </Section>
                {/* Mobile Visual (Visible only on small screens) */}
                <div className="lg:hidden mt-8 mb-8">
                    {section.visual}
                </div>
              </div>
            ))}
            
            {/* Conclusion Wrapper */}
            <div className="content-section py-16">
                <h2 className="text-2xl font-bold mb-4 text-slate-900">마치며: 전체 코드</h2>
                <p className="text-slate-700 text-lg leading-relaxed mb-6">
                    CNN의 전체적인 흐름을 하나의 파이토치 클래스로 구현하면 다음과 같습니다.
                </p>
                
                <CodeBlock 
                  title="Full CNN Model (PyTorch)"
                  code={`import torch
import torch.nn as nn
import torch.nn.functional as F

class SimpleCNN(nn.Module):
    def __init__(self):
        super(SimpleCNN, self).__init__()
        # 특징 추출기 (Conv & Pooling)
        self.features = nn.Sequential(
            nn.Conv2d(3, 16, kernel_size=3, padding=1),
            nn.ReLU(),
            nn.MaxPool2d(2, 2),
            
            nn.Conv2d(16, 32, kernel_size=3, padding=1),
            nn.ReLU(),
            nn.MaxPool2d(2, 2)
        )
        
        # 분류기 (FC Layer)
        # 이미지 크기에 따라 in_features 계산 필요 (예: 32*8*8)
        self.classifier = nn.Linear(32 * 8 * 8, 10)

    def forward(self, x):
        x = self.features(x)
        x = x.view(x.size(0), -1) # Flatten
        x = self.classifier(x)
        return x`}
                />

                <div className="mt-8 flex gap-2">
                    <span className="bg-white border border-slate-200 text-slate-600 px-3 py-1 rounded text-sm font-medium shadow-sm">#DeepLearning</span>
                    <span className="bg-white border border-slate-200 text-slate-600 px-3 py-1 rounded text-sm font-medium shadow-sm">#PyTorch</span>
                    <span className="bg-white border border-slate-200 text-slate-600 px-3 py-1 rounded text-sm font-medium shadow-sm">#Math</span>
                </div>
            </div>
          </div>

          {/* Right Column: Sticky Visuals (Visible only on large screens) */}
          <div className="hidden lg:block relative">
            <div className="sticky top-32 h-[calc(100vh-10rem)] flex items-center justify-center p-8 bg-slate-50/50 rounded-3xl border border-slate-200">
               <div className="w-full max-w-md">
                 {sectionsData[activeSection] ? sectionsData[activeSection].visual : <div className="text-slate-400">Explore CNN</div>}
               </div>
            </div>
          </div>

        </div>
      </main>

      {/* Footer */}
      <footer className="bg-white border-t border-slate-200 py-12 text-center text-slate-500 text-sm">
        <p>© 2022 hyundodo. Re-visualized with React & Tailwind.</p>
      </footer>
    </div>
  );
}