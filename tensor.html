<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>파이토치 텐서(Tensor) 완벽 가이드</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css" rel="stylesheet" />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-python.min.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@300;400;500;700&display=swap');
        
        body {
            font-family: 'Noto Sans KR', sans-serif;
            scroll-behavior: smooth;
        }

        /* Custom Scrollbar */
        ::-webkit-scrollbar {
            width: 8px;
        }
        ::-webkit-scrollbar-track {
            background: #f1f1f1; 
        }
        ::-webkit-scrollbar-thumb {
            background: #cbd5e1; 
            border-radius: 4px;
        }
        ::-webkit-scrollbar-thumb:hover {
            background: #94a3b8; 
        }

        .code-container {
            position: relative;
        }
        .copy-btn {
            position: absolute;
            top: 0.5rem;
            right: 0.5rem;
            opacity: 0;
            transition: opacity 0.2s;
        }
        .code-container:hover .copy-btn {
            opacity: 1;
        }
        
        /* Diagram Styles */
        .memory-block {
            transition: all 0.3s ease;
        }
        .memory-block:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
        }
    </style>
</head>
<body class="bg-slate-50 text-slate-800">

    <!-- Mobile Header -->
    <header class="lg:hidden bg-white p-4 shadow-sm sticky top-0 z-50 flex justify-between items-center">
        <h1 class="text-xl font-bold text-orange-600">PyTorch Tensor</h1>
        <button id="menu-btn" class="text-slate-600 focus:outline-none">
            <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 6h16M4 12h16M4 18h16"></path></svg>
        </button>
    </header>

    <div class="flex flex-col lg:flex-row min-h-screen">
        
        <!-- Sidebar Navigation -->
        <nav id="sidebar" class="hidden lg:block w-full lg:w-64 bg-white border-r border-slate-200 h-screen sticky top-0 overflow-y-auto z-40 p-6">
            <div class="mb-8 hidden lg:block">
                <h1 class="text-2xl font-bold text-slate-900">PyTorch<br><span class="text-orange-600">Tensor 구조체</span></h1>
                <p class="text-sm text-slate-500 mt-2">심층 분석 가이드</p>
            </div>
            
            <ul class="space-y-3 text-sm font-medium text-slate-600">
                <li><a href="#intro" class="toc-link block hover:text-orange-600 transition-colors py-1">1. 텐서(Tensor)란?</a></li>
                <li><a href="#creation" class="toc-link block hover:text-orange-600 transition-colors py-1">2. 텐서 생성하기</a></li>
                <li><a href="#indexing" class="toc-link block hover:text-orange-600 transition-colors py-1">3. 텐서의 인덱싱</a></li>
                <li><a href="#naming" class="toc-link block hover:text-orange-600 transition-colors py-1">4. 텐서에 이름 부여하기</a></li>
                <li><a href="#internals" class="toc-link block hover:text-orange-600 transition-colors py-1">5. 내부 구조 (Storage)</a></li>
                <li><a href="#metadata" class="toc-link block hover:text-orange-600 transition-colors py-1">6. 메타데이터 (Stride, Offset)</a></li>
                <li><a href="#api" class="toc-link block hover:text-orange-600 transition-colors py-1">7. 핵심 API 정리</a></li>
            </ul>
        </nav>

        <!-- Main Content -->
        <main class="flex-1 p-6 lg:p-12 max-w-5xl mx-auto">
            
            <!-- Intro Section -->
            <section id="intro" class="mb-20 pt-4">
                <div class="bg-orange-50 border-l-4 border-orange-500 p-6 rounded-r-lg mb-8">
                    <h2 class="text-2xl font-bold text-orange-800 mb-2">왜 텐서(Tensor)를 알아야 할까요?</h2>
                    <p class="text-slate-700 leading-relaxed">
                        딥러닝에서는 이미지, 텍스트, 오디오 같은 비정형 데이터를 컴퓨터가 이해할 수 있는 <strong>부동소수점 수(Floating Point)</strong>로 변환해야 합니다. 
                        이 데이터를 효율적으로 담고 연산하기 위해 고안된 자료구조가 바로 <strong>텐서(Tensor)</strong>입니다.<br><br>
                        텐서는 임의의 차원을 가지는 벡터나 행렬의 일반화된 개념으로, 파이토치의 가장 기본이 되는 핵심 단위입니다.
                    </p>
                </div>
            </section>

            <!-- Creation Section -->
            <section id="creation" class="mb-20 scroll-mt-24">
                <h2 class="text-3xl font-bold text-slate-900 mb-6 flex items-center">
                    <span class="bg-slate-200 text-slate-700 rounded-full w-10 h-10 flex items-center justify-center text-xl mr-3">2</span>
                    텐서 생성하기
                </h2>
                <p class="text-lg text-slate-600 mb-6 leading-relaxed">
                    파이토치 텐서는 파이썬의 리스트와 비슷하게 보이지만, 내부적으로는 훨씬 강력합니다. 
                    리스트는 메모리에 흩어져 있는 객체들의 주소를 담고 있지만(Boxing), 
                    <strong>텐서는 C언어 배열처럼 연속된 메모리 공간에 숫자 데이터를 직접 저장(Unboxing)</strong>하여 연산 속도가 매우 빠릅니다.
                </p>

                <div class="grid grid-cols-1 md:grid-cols-2 gap-6 mb-6">
                    <div class="bg-white rounded-xl shadow-sm border border-slate-200 p-6">
                        <h3 class="font-semibold text-slate-800 mb-4">파이썬 리스트 vs 텐서</h3>
                        <div class="code-container">
                            <pre><code class="language-python"># 파이썬 리스트 (메모리 비효율적)
a = [1.0, 2.0, 1.0]
print(a[0]) # 1.0

# 파이토치 텐서 (고성능 연산 최적화)
import torch
b = torch.tensor([1.0, 2.0, 1.0])
print(b[0]) # tensor(1.)</code></pre>
                        </div>
                    </div>
                    <div class="bg-white rounded-xl shadow-sm border border-slate-200 p-6">
                        <h3 class="font-semibold text-slate-800 mb-4">다양한 생성 방법</h3>
                        <div class="code-container">
                            <pre><code class="language-python"># 1로 채워진 크기 3의 텐서
a = torch.ones(3)
a[2] = 2.0 # 값 변경

# 0으로 채워진 텐서
point = torch.zeros(4) 
point[0] = 4.0 # 인덱싱으로 값 할당

# 2차원 텐서 (행렬)
mat = torch.tensor([[4.0, 1.0], 
                    [5.0, 3.0], 
                    [2.0, 1.0]])</code></pre>
                        </div>
                    </div>
                </div>
            </section>

            <!-- Indexing Section -->
            <section id="indexing" class="mb-20 scroll-mt-24">
                <h2 class="text-3xl font-bold text-slate-900 mb-6 flex items-center">
                    <span class="bg-slate-200 text-slate-700 rounded-full w-10 h-10 flex items-center justify-center text-xl mr-3">3</span>
                    텐서의 인덱싱
                </h2>
                <p class="text-slate-600 mb-6">
                    파이토치는 넘파이(NumPy)와 매우 유사한 인덱싱 방식을 지원합니다. 범위 인덱싱(Slicing)을 통해 원하는 데이터 영역만 쉽게 잘라낼 수 있습니다.
                </p>
                
                <div class="bg-slate-900 rounded-xl p-6 shadow-lg overflow-hidden relative">
                    <div class="absolute top-0 right-0 p-4 opacity-10 text-6xl text-white font-mono">[:]</div>
                    <pre><code class="language-python">point = torch.tensor([[4.0, 1.0], 
                      [5.0, 3.0], 
                      [2.0, 1.0]])

# [행, 열] 인덱싱
print(point[0, 1])  
# 출력: tensor(1.)

# 범위 인덱싱 (Slicing)
# 인덱스 1부터 끝까지의 모든 행, 그리고 모든 열(:)
print(point[1:, :]) 
# 출력: 
# tensor([[5., 3.],
#         [2., 1.]])</code></pre>
                </div>
            </section>

            <!-- Naming Section -->
            <section id="naming" class="mb-20 scroll-mt-24">
                <h2 class="text-3xl font-bold text-slate-900 mb-6 flex items-center">
                    <span class="bg-slate-200 text-slate-700 rounded-full w-10 h-10 flex items-center justify-center text-xl mr-3">4</span>
                    텐서에 이름 부여하기 (Named Tensor)
                </h2>
                <div class="bg-blue-50 text-blue-800 p-4 rounded-lg mb-6 text-sm">
                    <i class="fas fa-info-circle mr-2"></i> <strong>Tip:</strong> 딥러닝 모델을 짜다 보면 <code>(N, C, H, W)</code>인지 <code>(N, H, W, C)</code>인지 차원 순서가 헷갈릴 때가 많습니다. 이때 이름 있는 텐서를 사용하면 실수를 줄일 수 있습니다.
                </div>

                <div class="space-y-4">
                    <div class="bg-white border border-slate-200 rounded-lg p-6">
                        <h4 class="font-bold text-slate-700 mb-2">1. 생성 시 이름 부여</h4>
                        <pre><code class="language-python"># channels라는 차원 이름을 가진 텐서 생성
tensor_named = torch.tensor([0.124, 0.345, 0.363], names=['channels'])</code></pre>
                    </div>
                    
                    <div class="bg-white border border-slate-200 rounded-lg p-6">
                        <h4 class="font-bold text-slate-700 mb-2">2. refine_names로 이름 부여 및 정렬</h4>
                        <pre><code class="language-python"># img 텐서가 (Channel, Row, Col) 순서라고 가정
# ... (Ellipsis)는 앞부분 차원은 건너뛴다는 의미
img_named = img.refine_names(..., 'channels', 'row', 'columns')

# align_as를 사용하여 차원 순서 자동 맞춤 (Broadcasting 안전장치)
weight_tensor = tensor_named.align_as(img_named)</code></pre>
                    </div>
                </div>
            </section>

            <!-- Internals Section -->
            <section id="internals" class="mb-20 scroll-mt-24">
                <h2 class="text-3xl font-bold text-slate-900 mb-6 flex items-center">
                    <span class="bg-slate-200 text-slate-700 rounded-full w-10 h-10 flex items-center justify-center text-xl mr-3">5</span>
                    내부 구조: Storage와 View
                </h2>
                <p class="text-slate-600 mb-6">
                    이 부분이 가장 중요합니다! 우리가 보는 텐서는 2차원, 3차원 모양을 하고 있지만, 
                    <strong>실제 컴퓨터 메모리(RAM) 상에는 1줄로 길게 늘어선 1차원 배열(Storage)</strong>로 저장됩니다.
                </p>

                <div class="bg-white border border-slate-300 rounded-xl p-6 shadow-sm mb-6">
                    <h3 class="text-lg font-bold text-center mb-6">논리적 형태 vs 물리적 저장공간</h3>
                    
                    <div class="flex flex-col md:flex-row items-center justify-center gap-12">
                        <!-- Logical View -->
                        <div class="text-center">
                            <p class="font-bold text-orange-600 mb-2">텐서 (Tensor View)</p>
                            <p class="text-xs text-slate-500 mb-2">Shape: (3, 2)</p>
                            <div class="grid grid-cols-2 gap-2 bg-slate-100 p-4 rounded-lg border border-slate-200">
                                <div class="bg-white border border-slate-300 p-3 rounded text-center font-mono font-bold">4.0</div>
                                <div class="bg-white border border-slate-300 p-3 rounded text-center font-mono font-bold">1.0</div>
                                <div class="bg-white border border-slate-300 p-3 rounded text-center font-mono font-bold">5.0</div>
                                <div class="bg-white border border-slate-300 p-3 rounded text-center font-mono font-bold">3.0</div>
                                <div class="bg-white border border-slate-300 p-3 rounded text-center font-mono font-bold">2.0</div>
                                <div class="bg-white border border-slate-300 p-3 rounded text-center font-mono font-bold">1.0</div>
                            </div>
                        </div>

                        <div class="hidden md:block text-slate-400 text-2xl">➔ 매핑 ➔</div>
                        <div class="md:hidden text-slate-400 text-2xl">⬇ 매핑 ⬇</div>

                        <!-- Physical Storage -->
                        <div class="text-center">
                            <p class="font-bold text-indigo-600 mb-2">저장소 (Storage)</p>
                            <p class="text-xs text-slate-500 mb-2">1D Continuous Memory</p>
                            <div class="flex flex-col gap-1 bg-slate-100 p-4 rounded-lg border border-slate-200">
                                <div class="flex gap-2">
                                    <div class="memory-block bg-indigo-50 border border-indigo-200 w-12 h-10 flex items-center justify-center font-mono text-sm rounded">4.0</div>
                                    <div class="memory-block bg-indigo-50 border border-indigo-200 w-12 h-10 flex items-center justify-center font-mono text-sm rounded">1.0</div>
                                    <div class="memory-block bg-indigo-50 border border-indigo-200 w-12 h-10 flex items-center justify-center font-mono text-sm rounded">5.0</div>
                                    <div class="memory-block bg-indigo-50 border border-indigo-200 w-12 h-10 flex items-center justify-center font-mono text-sm rounded">3.0</div>
                                    <div class="memory-block bg-indigo-50 border border-indigo-200 w-12 h-10 flex items-center justify-center font-mono text-sm rounded">2.0</div>
                                    <div class="memory-block bg-indigo-50 border border-indigo-200 w-12 h-10 flex items-center justify-center font-mono text-sm rounded">1.0</div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>

                <div class="code-container bg-slate-50 p-4 rounded-lg border border-slate-200">
                    <pre><code class="language-python"># 스토리지 직접 접근 예시
point = torch.tensor([[4.0, 1.0], [5.0, 3.0], [2.0, 1.0]])

# 실제 저장된 값 확인 (1차원 배열)
print(point.storage())
# 출력: 4.0, 1.0, 5.0, 3.0, 2.0, 1.0 ...

# 스토리지의 값을 바꾸면 텐서의 값도 바뀝니다 (같은 메모리 공유)
point_storage = point.storage()
point_storage[0] = 99.0 
print(point) # (0,0) 위치의 값이 99.0으로 변경됨</code></pre>
                </div>
            </section>

            <!-- Metadata Section -->
            <section id="metadata" class="mb-20 scroll-mt-24">
                <h2 class="text-3xl font-bold text-slate-900 mb-6 flex items-center">
                    <span class="bg-slate-200 text-slate-700 rounded-full w-10 h-10 flex items-center justify-center text-xl mr-3">6</span>
                    메타데이터: Stride, Offset, Size
                </h2>
                <p class="text-slate-600 mb-6">
                    1차원 배열인 Storage를 어떻게 2차원 행렬처럼 보여줄까요? 비밀은 <strong>메타데이터</strong>에 있습니다.
                </p>

                <div class="grid grid-cols-1 md:grid-cols-3 gap-6 mb-8">
                    <div class="bg-white p-5 rounded-lg border border-slate-200 shadow-sm hover:border-orange-300 transition-colors">
                        <h4 class="font-bold text-slate-800 text-lg mb-2">Size (Shape)</h4>
                        <p class="text-sm text-slate-600">텐서의 모양입니다.<br>예: <code>(3, 2)</code><br>3개의 행과 2개의 열.</p>
                    </div>
                    <div class="bg-white p-5 rounded-lg border border-slate-200 shadow-sm hover:border-orange-300 transition-colors">
                        <h4 class="font-bold text-slate-800 text-lg mb-2">Offset</h4>
                        <p class="text-sm text-slate-600">텐서의 시작점이 Storage 어디에 위치하는지 나타내는 인덱스입니다. (기본 0)</p>
                    </div>
                    <div class="bg-white p-5 rounded-lg border border-slate-200 shadow-sm hover:border-orange-300 transition-colors">
                        <h4 class="font-bold text-slate-800 text-lg mb-2">Stride (보폭)</h4>
                        <p class="text-sm text-slate-600">다음 차원으로 이동하기 위해 Storage상에서 몇 칸을 건너뛰어야 하는지 나타냅니다.</p>
                    </div>
                </div>

                <div class="bg-slate-800 text-white rounded-xl p-8 relative overflow-hidden">
                    <h3 class="text-xl font-bold mb-4 text-orange-400">Stride 시각화 예제</h3>
                    <p class="mb-6 opacity-80">
                        Shape가 <code>(3, 2)</code>인 텐서에서:<br>
                        - <strong>행(Row)을 하나 내려가려면</strong>: 열의 개수(2)만큼 건너뛰어야 합니다. (Stride[0] = 2)<br>
                        - <strong>열(Col)을 하나 옆으로 가려면</strong>: 바로 옆 칸으로 갑니다. (Stride[1] = 1)
                    </p>
                    
                    <div class="flex items-center space-x-2 font-mono text-sm md:text-base overflow-x-auto pb-4">
                        <div class="flex flex-col items-center">
                            <span class="text-xs text-orange-400 mb-1">idx 0</span>
                            <div class="w-12 h-12 bg-orange-600 flex items-center justify-center rounded border-2 border-white">4.0</div>
                            <span class="text-xs mt-1 text-orange-300">(0,0)</span>
                        </div>
                        <div class="w-8 h-px bg-slate-600"></div>
                        <div class="flex flex-col items-center">
                            <span class="text-xs text-slate-400 mb-1">idx 1</span>
                            <div class="w-12 h-12 bg-slate-700 flex items-center justify-center rounded border border-slate-600">1.0</div>
                            <span class="text-xs mt-1 text-slate-500">(0,1)</span>
                        </div>
                        <div class="w-8 h-px bg-slate-600 relative">
                            <span class="absolute -top-3 left-0 w-full text-center text-[10px] text-green-400">Jump 2!</span>
                        </div>
                        <div class="flex flex-col items-center">
                            <span class="text-xs text-green-400 mb-1">idx 2</span>
                            <div class="w-12 h-12 bg-green-700 flex items-center justify-center rounded border-2 border-white">5.0</div>
                            <span class="text-xs mt-1 text-green-300">(1,0)</span>
                        </div>
                        <div class="w-8 h-px bg-slate-600"></div>
                        <div class="flex flex-col items-center">
                            <div class="w-12 h-12 bg-slate-700 flex items-center justify-center rounded border border-slate-600">...</div>
                        </div>
                    </div>
                    <p class="mt-4 text-sm bg-black/30 p-3 rounded">
                        <span class="text-orange-400">주황색</span>에서 <span class="text-green-400">초록색</span>으로(행 이동) 가기 위해, 실제 메모리에서는 인덱스 0에서 2로 <strong>2칸 점프</strong>했습니다. 이것이 Stride입니다.
                    </p>
                </div>
            </section>

            <!-- API Section -->
            <section id="api" class="mb-20 scroll-mt-24">
                <h2 class="text-3xl font-bold text-slate-900 mb-6 flex items-center">
                    <span class="bg-slate-200 text-slate-700 rounded-full w-10 h-10 flex items-center justify-center text-xl mr-3">7</span>
                    공식 문서 활용하기
                </h2>
                <p class="text-slate-600 mb-6">
                    텐서 API는 매우 방대합니다. 모든 것을 외울 수는 없지만, 공식 문서를 읽는 법을 아는 것이 중요합니다.
                </p>
                <div class="bg-gradient-to-r from-orange-100 to-orange-50 border border-orange-200 p-6 rounded-lg text-center">
                    <h3 class="font-bold text-lg text-orange-900 mb-2">PyTorch 공식 문서</h3>
                    <p class="text-orange-800 mb-4 text-sm">최신 텐서 연산과 예제를 확인하려면 아래 버튼을 클릭하세요.</p>
                    <a href="https://pytorch.org/docs/stable/index.html" target="_blank" class="inline-flex items-center px-6 py-3 bg-orange-600 text-white font-bold rounded-full hover:bg-orange-700 transition-colors shadow-md">
                        Documentation 바로가기
                        <svg class="w-4 h-4 ml-2" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 6H6a2 2 0 00-2 2v10a2 2 0 002 2h10a2 2 0 002-2v-4M14 4h6m0 0v6m0-6L10 14"></path></svg>
                    </a>
                </div>
            </section>

            <!-- Footer -->
            <footer class="border-t border-slate-200 pt-8 pb-20 text-center text-slate-400 text-sm">
                <p>Based on the concept of "PyTorch Tensor Structure"</p>
                <p class="mt-2">Created for educational purposes.</p>
            </footer>

        </main>
    </div>

    <!-- Scripts -->
    <script>
        // Mobile Menu Toggle
        const menuBtn = document.getElementById('menu-btn');
        const sidebar = document.getElementById('sidebar');
        
        menuBtn.addEventListener('click', () => {
            sidebar.classList.toggle('hidden');
            sidebar.classList.toggle('fixed');
            sidebar.classList.toggle('inset-0');
            sidebar.classList.toggle('bg-white');
            sidebar.classList.toggle('z-40');
        });

        // Close sidebar on link click (Mobile)
        document.querySelectorAll('.toc-link').forEach(link => {
            link.addEventListener('click', () => {
                if (window.innerWidth < 1024) {
                    sidebar.classList.add('hidden');
                    sidebar.classList.remove('fixed', 'inset-0', 'bg-white', 'z-40');
                }
            });
        });

        // Copy Code Functionality
        document.querySelectorAll('pre code').forEach((codeBlock) => {
            const container = codeBlock.parentElement.parentElement;
            
            // Create copy button if it's inside a .code-container
            if (container.classList.contains('code-container')) {
                const button = document.createElement('button');
                button.className = 'copy-btn bg-white text-slate-500 hover:text-orange-600 border border-slate-200 rounded px-2 py-1 text-xs font-bold shadow-sm';
                button.innerHTML = 'Copy';
                
                button.addEventListener('click', () => {
                    const code = codeBlock.innerText;
                    navigator.clipboard.writeText(code).then(() => {
                        button.innerHTML = 'Copied!';
                        setTimeout(() => { button.innerHTML = 'Copy'; }, 2000);
                    });
                });
                
                container.appendChild(button);
            }
        });

        // TOC Active State Highlight using Intersection Observer
        const sections = document.querySelectorAll('section');
        const navLinks = document.querySelectorAll('.toc-link');

        const observerOptions = {
            root: null,
            rootMargin: '-100px 0px -60% 0px', // Trigger when section is near top
            threshold: 0
        };

        const observer = new IntersectionObserver((entries) => {
            entries.forEach(entry => {
                if (entry.isIntersecting) {
                    const id = entry.target.getAttribute('id');
                    
                    navLinks.forEach(link => {
                        link.classList.remove('text-orange-600', 'font-bold');
                        if (link.getAttribute('href') === `#${id}`) {
                            link.classList.add('text-orange-600', 'font-bold');
                        }
                    });
                }
            });
        }, observerOptions);

        sections.forEach(section => {
            observer.observe(section);
        });
    </script>
</body>
</html>