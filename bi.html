<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ì´ì§„ ë¶„ë¥˜(Binary Classification) ì™„ì „ ì •ë³µ</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.plot.ly/plotly-2.24.1.min.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/atom-one-dark.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/highlight.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjs/11.8.0/math.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@300;400;500;700&family=Fira+Code:wght@400;500&display=swap');
        
        body { font-family: 'Noto Sans KR', sans-serif; background-color: #0f172a; color: #e2e8f0; }
        code { font-family: 'Fira Code', monospace; }
        .glass-panel {
            background: rgba(30, 41, 59, 0.7);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 1rem;
        }
        .code-block {
            background: #1e1e1e;
            border-radius: 0.5rem;
            padding: 1rem;
            overflow-x: auto;
            margin: 1rem 0;
            border: 1px solid #333;
        }
        .step-number {
            background: linear-gradient(135deg, #3b82f6, #8b5cf6);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            font-weight: 800;
        }
        .fade-in { opacity: 0; transform: translateY(20px); transition: opacity 0.6s ease-out, transform 0.6s ease-out; }
        .fade-in.visible { opacity: 1; transform: translateY(0); }
        
        /* Custom Scrollbar */
        ::-webkit-scrollbar { width: 10px; }
        ::-webkit-scrollbar-track { background: #0f172a; }
        ::-webkit-scrollbar-thumb { background: #475569; border-radius: 5px; }
        ::-webkit-scrollbar-thumb:hover { background: #64748b; }
    </style>
</head>
<body class="antialiased selection:bg-purple-500 selection:text-white">

    <!-- Hero Section -->
    <header class="min-h-screen flex flex-col justify-center items-center text-center p-6 relative overflow-hidden">
        <div class="absolute inset-0 bg-[url('https://source.unsplash.com/1600x900/?technology,ai')] bg-cover bg-center opacity-10"></div>
        <div class="absolute inset-0 bg-gradient-to-b from-transparent to-[#0f172a]"></div>
        
        <div class="relative z-10 max-w-4xl">
            <h1 class="text-5xl md:text-7xl font-bold mb-6 bg-clip-text text-transparent bg-gradient-to-r from-blue-400 to-purple-500">
                Binary Classification
            </h1>
            <p class="text-xl md:text-2xl text-gray-300 mb-8 font-light">
                PyTorchë¡œ ë°°ìš°ëŠ” ë”¥ëŸ¬ë‹ì˜ ê¸°ì´ˆ: 0ê³¼ 1ì„ êµ¬ë¶„í•˜ëŠ” ë°©ë²•
            </p>
            <p class="text-md text-gray-400 mb-12">
                ì´ˆë³´ìë„ ì´í•´í•  ìˆ˜ ìˆëŠ” ì‹œê°ì  ê°€ì´ë“œì™€ í•¨ê»˜ ì½”ë“œë¥¼ í•œ ì¤„ì”© ëœ¯ì–´ë´…ì‹œë‹¤.
            </p>
            <a href="#step1" class="px-8 py-4 bg-blue-600 hover:bg-blue-700 text-white rounded-full transition-all shadow-lg shadow-blue-500/30 font-bold text-lg animate-bounce inline-block">
                ì‹œì‘í•˜ê¸° â†“
            </a>
        </div>
    </header>

    <!-- Main Content -->
    <main class="max-w-6xl mx-auto px-4 py-12 space-y-32">

        <!-- Step 1 -->
        <section id="step1" class="step-section fade-in">
            <div class="flex flex-col md:flex-row gap-8 items-start">
                <div class="md:w-1/2 space-y-6">
                    <h2 class="text-4xl font-bold"><span class="step-number">STEP 1.</span> ë°ì´í„° ëª¨ìœ¼ê¸°</h2>
                    <p class="text-gray-300 leading-relaxed">
                        ëª¨ë“  ë¨¸ì‹ ëŸ¬ë‹ì˜ ì‹œì‘ì€ ë°ì´í„°ì…ë‹ˆë‹¤. ì—¬ê¸°ì„œëŠ” ë‘ ê°€ì§€ ì¢…ë¥˜(Class)ì˜ ë°ì´í„°ë¥¼ ì¸ìœ„ì ìœ¼ë¡œ ìƒì„±í•©ë‹ˆë‹¤.
                        <br><br>
                        <code>Class 0</code>ê³¼ <code>Class 1</code> ë°ì´í„°ë¥¼ ê°ê° ë‹¤ë¥¸ ìœ„ì¹˜(í‰ê· )ì— ìƒì„±í•˜ì—¬, ì»´í“¨í„°ê°€ ì´ ë‘˜ì„ êµ¬ë¶„í•  ìˆ˜ ìˆëŠ”ì§€ ì‹¤í—˜í•  ê²ƒì…ë‹ˆë‹¤.
                    </p>
                    
                    <div class="glass-panel p-6">
                        <h3 class="text-xl font-bold mb-4 text-blue-300">ğŸ’¡ ì½”ë“œ ì„¤ëª…</h3>
                        <ul class="list-disc list-inside space-y-2 text-gray-300 text-sm">
                            <li><code>torch.randn</code>: ì •ê·œë¶„í¬ë¥¼ ë”°ë¥´ëŠ” ëœë¤í•œ ìˆ«ìë¥¼ ìƒì„±í•©ë‹ˆë‹¤.</li>
                            <li><code>hstack/vstack</code>: ìƒì„±í•œ ë°ì´í„°ë¥¼ ê°€ë¡œ/ì„¸ë¡œë¡œ í•©ì³ í•˜ë‚˜ì˜ í° ë°ì´í„°ì…‹ì„ ë§Œë“­ë‹ˆë‹¤.</li>
                            <li><code>random5</code>: Class 2 ë°ì´í„°ëŠ” 5ë¥¼ ë”í•´ ë©€ë¦¬ ë–¨ì–´ëœ¨ë ¤ ë†“ìŠµë‹ˆë‹¤.</li>
                        </ul>
                    </div>

                    <div class="code-block">
                        <div class="flex justify-between text-xs text-gray-500 mb-2">
                            <span>Python (PyTorch)</span>
                            <span>binary_classification.ipynb</span>
                        </div>
<pre><code class="language-python">import torch
import matplotlib.pyplot as plt

# case 1
N = 20
random0 = torch.randn(int(N/2),1)
random5 = torch.randn(int(N/2),1) + 5

# class1 ë°ì´í„°: x1ì€ random0, x2ëŠ” random5
class1_data = torch.hstack([random0, random5])
# class2 ë°ì´í„°: x1ì€ random5, x2ëŠ” random0
class2_data = torch.hstack([random5, random0])

class1_label = torch.ones(int(N/2),1)
class2_label = torch.zeros(int(N/2),1)

X = torch.vstack([class1_data, class2_data])
y = torch.vstack([class1_label, class2_label])

print(X)
print(y)

# ì‹œê°í™” ì½”ë“œ
plt.plot(class1_data[:,0], class1_data[:,1], 'o')
plt.plot(class2_data[:,0], class2_data[:,1], 'ro')
plt.xlabel('x1')
plt.ylabel('x2')
plt.grid()
</code></pre>
                    </div>
                </div>

                <div class="md:w-1/2 sticky top-10">
                    <div class="glass-panel p-4">
                        <div class="flex justify-between items-center mb-4">
                            <h3 class="text-lg font-bold">ğŸ“Š ë°ì´í„° ì‹œê°í™” (ì¸í„°ë™í‹°ë¸Œ)</h3>
                            <button onclick="generateData()" class="px-4 py-2 bg-purple-600 hover:bg-purple-700 rounded text-sm transition">ë°ì´í„° ì¬ìƒì„±</button>
                        </div>
                        <div id="dataPlot" style="width:100%; height:400px;"></div>
                        <p class="text-xs text-gray-400 mt-2 text-center">íŒŒë€ì (Class 1)ê³¼ ë¹¨ê°„ì (Class 0)ì´ ì„ì´ì§€ ì•Šê³  êµ¬ë¶„ë˜ì–´ ìˆë‚˜ìš”?</p>
                    </div>
                </div>
            </div>
        </section>

        <!-- Step 2 -->
        <section id="step2" class="step-section fade-in">
            <div class="flex flex-col md:flex-row-reverse gap-8 items-start">
                <div class="md:w-1/2 space-y-6">
                    <h2 class="text-4xl font-bold"><span class="step-number">STEP 2.</span> ëª¨ë¸ ë§Œë“¤ê¸°</h2>
                    <p class="text-gray-300 leading-relaxed">
                        ì´ì œ ë°ì´í„°ë¥¼ êµ¬ë¶„í•  'ë‡Œ'ë¥¼ ë§Œë“¤ ì°¨ë¡€ì…ë‹ˆë‹¤. ìš°ë¦¬ëŠ” <strong>MLP (Multi-Layer Perceptron)</strong>ë¼ëŠ” ì‹ ê²½ë§ì„ ì‚¬ìš©í•©ë‹ˆë‹¤.
                        <br><br>
                        ì…ë ¥(x1, x2)ì„ ë°›ì•„ì„œ â†’ ë³µì¡í•œ ê³„ì‚°(Linear)ì„ ê±°ì¹˜ê³  â†’ í™œì„±í™” í•¨ìˆ˜(Sigmoid)ë¥¼ í†µê³¼í•´ â†’ ìµœì¢…ì ìœ¼ë¡œ 0 ë˜ëŠ” 1ì— ê°€ê¹Œìš´ í™•ë¥ ì„ ì¶œë ¥í•©ë‹ˆë‹¤.
                    </p>

                    <div class="glass-panel p-6">
                        <h3 class="text-xl font-bold mb-4 text-purple-300">ğŸ§  ëª¨ë¸ êµ¬ì¡°</h3>
                        <div class="flex items-center justify-center space-x-4 text-sm">
                            <div class="text-center p-2 border border-gray-600 rounded bg-gray-800">ì…ë ¥ (2ê°œ)</div>
                            <span>â†’</span>
                            <div class="text-center p-2 border border-blue-500 rounded bg-blue-900/30">ì€ë‹‰ì¸µ (100ê°œ)</div>
                            <span>â†’</span>
                            <div class="text-center p-2 border border-green-500 rounded bg-green-900/30">ì¶œë ¥ (1ê°œ)</div>
                        </div>
                        <p class="mt-4 text-sm text-gray-400">
                            * <code>nn.Linear(2, 100)</code>: 2ê°œì˜ ì…ë ¥ì„ ë°›ì•„ 100ê°œì˜ íŠ¹ì§•ìœ¼ë¡œ ë»¥íŠ€ê¸°í•©ë‹ˆë‹¤.<br>
                            * <code>nn.Sigmoid()</code>: ê°’ì„ 0~1 ì‚¬ì´ë¡œ ì••ì¶•í•˜ì—¬ ë¹„ì„ í˜•ì„±ì„ ì¶”ê°€í•©ë‹ˆë‹¤.
                        </p>
                    </div>

                    <div class="code-block">
<pre><code class="language-python">from torch import nn

class MLP(nn.Module):
    def __init__(self):
        super().__init__()

        # case 1, plain
        # ì…ë ¥(2) -> ì€ë‹‰(100) -> í™œì„±í™” -> ì€ë‹‰(100) -> ì¶œë ¥(1) -> í™œì„±í™”
        self.linear = nn.Sequential(
            nn.Linear(2, 100), # 10,100,1000 ë“±ìœ¼ë¡œ ë°”ê¿”ë³´ë©° ì‹¤í—˜ ê°€ëŠ¥
            nn.Sigmoid(),
            nn.Linear(100, 1), # nodeê°€ ë§ì„ìˆ˜ë¡ í‘œí˜„ë ¥ì´ ì¢‹ì•„ì§
            nn.Sigmoid()
        )

    def forward(self, x):
        x = self.linear(x)
        return x

model = MLP()
print(model)

# í…ŒìŠ¤íŠ¸ ì‹¤í–‰ (í•™ìŠµ ì „)
model.eval()
with torch.no_grad():
    # ì„ì˜ì˜ ë°ì´í„° 5ê°œë¥¼ ë„£ì–´ ì¶œë ¥ í™•ì¸
    print(model(torch.randn(5,2)).shape) 
</code></pre>
                    </div>
                </div>

                <div class="md:w-1/2 sticky top-10">
                    <div class="glass-panel p-8 flex flex-col items-center justify-center min-h-[400px]">
                        <div class="relative w-64 h-64">
                            <!-- Simple SVG Visualization of NN -->
                            <svg viewBox="0 0 200 200" class="w-full h-full drop-shadow-2xl">
                                <!-- Input Layer -->
                                <circle cx="50" cy="60" r="10" fill="#94a3b8" />
                                <circle cx="50" cy="140" r="10" fill="#94a3b8" />
                                <text x="30" y="65" fill="white" font-size="10">x1</text>
                                <text x="30" y="145" fill="white" font-size="10">x2</text>

                                <!-- Hidden Layer -->
                                <circle cx="100" cy="40" r="8" fill="#3b82f6" opacity="0.8" />
                                <circle cx="100" cy="70" r="8" fill="#3b82f6" opacity="0.8" />
                                <circle cx="100" cy="100" r="8" fill="#3b82f6" opacity="0.8" />
                                <circle cx="100" cy="130" r="8" fill="#3b82f6" opacity="0.8" />
                                <circle cx="100" cy="160" r="8" fill="#3b82f6" opacity="0.8" />

                                <!-- Output Layer -->
                                <circle cx="150" cy="100" r="10" fill="#22c55e" />
                                <text x="165" y="105" fill="white" font-size="10">y (0~1)</text>

                                <!-- Connections (Simplified) -->
                                <line x1="60" y1="60" x2="92" y2="40" stroke="#475569" stroke-width="1" />
                                <line x1="60" y1="60" x2="92" y2="160" stroke="#475569" stroke-width="1" />
                                <line x1="60" y1="140" x2="92" y2="40" stroke="#475569" stroke-width="1" />
                                <line x1="60" y1="140" x2="92" y2="160" stroke="#475569" stroke-width="1" />
                                
                                <line x1="108" y1="40" x2="140" y2="100" stroke="#475569" stroke-width="1" />
                                <line x1="108" y1="160" x2="140" y2="100" stroke="#475569" stroke-width="1" />
                            </svg>
                        </div>
                        <p class="text-center mt-4 font-bold text-lg">Multi-Layer Perceptron</p>
                        <p class="text-center text-sm text-gray-400 px-4">
                            ë°ì´í„°ê°€ ë³µì¡í•œ ê·¸ë¬¼ë§(ì‹ ê²½ë§)ì„ í†µê³¼í•˜ë©° 0ê³¼ 1 ì‚¬ì´ì˜ í™•ë¥ ê°’ìœ¼ë¡œ ë³€í™˜ë©ë‹ˆë‹¤.
                        </p>
                    </div>
                </div>
            </div>
        </section>

        <!-- Step 3 -->
        <section id="step3" class="step-section fade-in">
            <div class="flex flex-col md:flex-row gap-8 items-start">
                <div class="md:w-1/2 space-y-6">
                    <h2 class="text-4xl font-bold"><span class="step-number">STEP 3.</span> ëª¨ë¸ í•™ìŠµì‹œí‚¤ê¸°</h2>
                    <p class="text-gray-300 leading-relaxed">
                        ì´ì œ ëª¨ë¸ì„ ê³µë¶€ì‹œí‚¬ ì°¨ë¡€ì…ë‹ˆë‹¤. (Training)<br>
                        ëª¨ë¸ì´ ì˜ˆì¸¡í•œ ê°’ê³¼ ì •ë‹µ ì‚¬ì´ì˜ ì°¨ì´(Loss)ë¥¼ êµ¬í•˜ê³ , ì´ ì°¨ì´ë¥¼ ì¤„ì´ëŠ” ë°©í–¥ìœ¼ë¡œ ëª¨ë¸ì„ ìˆ˜ì •í•©ë‹ˆë‹¤(Optimizer).
                    </p>

                    <div class="glass-panel p-6 border-l-4 border-yellow-500">
                        <h3 class="text-lg font-bold mb-2">ğŸ”¥ í•™ìŠµì˜ í•µì‹¬ ìš”ì†Œ</h3>
                        <ul class="list-disc list-inside space-y-1 text-sm text-gray-300">
                            <li><strong>Optimizer (SGD/Adam)</strong>: ì˜¤ì°¨ë¥¼ ì¤„ì´ê¸° ìœ„í•´ íŒŒë¼ë¯¸í„°ë¥¼ ìˆ˜ì •í•˜ëŠ” ë„êµ¬</li>
                            <li><strong>Criterion (BCELoss)</strong>: ì´ì§„ ë¶„ë¥˜ ì „ìš© ì˜¤ì°¨ ê³„ì‚° í•¨ìˆ˜ (Binary Cross Entropy)</li>
                            <li><strong>Epoch</strong>: ì „ì²´ ë°ì´í„°ë¥¼ ê³µë¶€í•˜ëŠ” íšŸìˆ˜</li>
                        </ul>
                    </div>

                    <div class="code-block">
<pre><code class="language-python">from torch import optim

LR = 1e-1 # í•™ìŠµë¥  (Learning Rate)
EPOCH = 100 # ë°˜ë³µ íšŸìˆ˜

# SGD (Stochastic Gradient Descent) ìµœì í™” ë„êµ¬ ì‚¬ìš©
optimizer = optim.SGD(model.parameters(), lr=LR)
# ì´ì§„ ë¶„ë¥˜ë¥¼ ìœ„í•œ Loss Function
criterion = nn.BCELoss()

loss_history = []

model.train() # í•™ìŠµ ëª¨ë“œ ì „í™˜
for ep in range(EPOCH):
    # 1. ì˜ˆì¸¡ (Inference)
    y_hat = model(X)
    
    # 2. ì˜¤ì°¨ ê³„ì‚° (Loss)
    loss = criterion(y_hat, y)
    
    # 3. í•™ìŠµ (Update)
    optimizer.zero_grad() # ì´ì „ gradient ì´ˆê¸°í™”
    loss.backward()       # ì—­ì „íŒŒ (Backpropagation)
    optimizer.step()      # ê°€ì¤‘ì¹˜ ê°±ì‹ 
    
    # ê¸°ë¡
    loss_history += [loss.item()]
    print(f"Epoch: {ep+1}, train loss: {loss.item():.4f}")

# Loss ê·¸ë˜í”„ ê·¸ë¦¬ê¸°
plt.plot(range(1,EPOCH+1), loss_history)
plt.xlabel("Epoch")
plt.ylabel("Loss")
</code></pre>
                    </div>
                </div>

                <div class="md:w-1/2 sticky top-10">
                    <div class="glass-panel p-4">
                        <div class="flex justify-between items-center mb-4">
                            <h3 class="text-lg font-bold">ğŸ“‰ í•™ìŠµ ê³¼ì • ì‹œë®¬ë ˆì´ì…˜</h3>
                            <button id="trainBtn" onclick="simulateTraining()" class="px-4 py-2 bg-green-600 hover:bg-green-700 rounded text-sm transition font-bold shadow-lg shadow-green-500/30">
                                â–¶ í•™ìŠµ ì‹œì‘ (Start)
                            </button>
                        </div>
                        <div id="lossPlot" style="width:100%; height:300px;"></div>
                        <div class="mt-4 p-3 bg-black/30 rounded border border-gray-700">
                            <div class="flex justify-between text-sm">
                                <span class="text-gray-400">Current Epoch:</span>
                                <span id="currentEpoch" class="font-mono text-yellow-400">0</span>
                            </div>
                            <div class="flex justify-between text-sm mt-1">
                                <span class="text-gray-400">Current Loss:</span>
                                <span id="currentLoss" class="font-mono text-red-400">-</span>
                            </div>
                            <!-- Progress Bar -->
                            <div class="w-full bg-gray-700 h-2 rounded-full mt-3 overflow-hidden">
                                <div id="progressBar" class="bg-green-500 h-full w-0 transition-all duration-100"></div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </section>

        <!-- Step 4 -->
        <section id="step4" class="step-section fade-in pb-20">
            <div class="flex flex-col gap-8">
                <div class="text-center max-w-3xl mx-auto space-y-6">
                    <h2 class="text-4xl font-bold"><span class="step-number">STEP 4.</span> ê²°ê³¼ í™•ì¸ (Test)</h2>
                    <p class="text-gray-300">
                        í•™ìŠµëœ ëª¨ë¸ì´ ê³µê°„ì„ ì–´ë–»ê²Œ ë‚˜ëˆ„ì—ˆëŠ”ì§€ í™•ì¸í•´ë´…ì‹œë‹¤.
                        <br>
                        ëª¨ë¸ì€ ì…ë ¥ ê³µê°„(x1, x2) ì „ì²´ì— ëŒ€í•´ 0~1 ì‚¬ì´ì˜ í™•ë¥ ê°’(ë†’ì´, z)ì„ ì¶œë ¥í•©ë‹ˆë‹¤. ì´ë¥¼ 3D í‘œë©´ìœ¼ë¡œ ì‹œê°í™”í•˜ë©´ <strong>ê²°ì • ê²½ê³„(Decision Boundary)</strong>ë¥¼ ë³¼ ìˆ˜ ìˆìŠµë‹ˆë‹¤.
                    </p>
                </div>

                <div class="grid md:grid-cols-2 gap-8">
                    <div class="code-block h-fit">
<pre><code class="language-python"># í…ŒìŠ¤íŠ¸ ë°ì´í„° ìƒì„± (ê²©ì í˜•íƒœ)
x1_test = torch.linspace(-10, 10, 30)
x2_test = torch.linspace(-10, 10, 30)
X1_test, X2_test = torch.meshgrid(x1_test, x2_test)
X_test = torch.cat([X1_test.unsqueeze(dim=2), X2_test.unsqueeze(dim=2)], dim=2)

model.eval() # í‰ê°€ ëª¨ë“œ
with torch.no_grad():
    y_hat = model(X_test)

Y_hat = y_hat.squeeze()

# 3D ì‹œê°í™” (Plotly)
import plotly.graph_objects as go

fig = go.Figure(data=[go.Surface(
    x=X1_test, 
    y=X2_test, 
    z=Y_hat, 
    colorscale="viridis", 
    opacity=0.5
)])
fig.update_layout(title='Binary Classification Boundary')
fig.show()
</code></pre>
                    </div>

                    <div class="glass-panel p-2">
                        <div id="resultPlot" style="width:100%; height:500px;"></div>
                        <p class="text-center text-sm text-gray-400 p-2">
                            ë§ˆìš°ìŠ¤ë¥¼ ì‚¬ìš©í•˜ì—¬ ê·¸ë˜í”„ë¥¼ íšŒì „ì‹œì¼œ ë³´ì„¸ìš”.<br>
                            ë…¸ë€ìƒ‰ ì˜ì—­ì€ 1, ë³´ë¼ìƒ‰ ì˜ì—­ì€ 0ìœ¼ë¡œ ì˜ˆì¸¡í•˜ëŠ” êµ¬ê°„ì…ë‹ˆë‹¤.
                        </p>
                    </div>
                </div>
            </div>
        </section>

    </main>

    <!-- Footer -->
    <footer class="text-center py-12 text-gray-500 text-sm border-t border-gray-800">
        <p>Based on uploaded Jupyter Notebook (binary_classification.ipynb)</p>
        <p>Implemented with Tailwind CSS & Plotly.js</p>
    </footer>

    <script>
        // --- 1. Syntax Highlighting ---
        hljs.highlightAll();

        // --- 2. Scroll Animation ---
        const observer = new IntersectionObserver((entries) => {
            entries.forEach(entry => {
                if (entry.isIntersecting) {
                    entry.target.classList.add('visible');
                }
            });
        }, { threshold: 0.1 });

        document.querySelectorAll('.fade-in').forEach(el => observer.observe(el));

        // --- 3. Step 1: Data Generation Logic & Plot ---
        function generateRandomData(n, mean, std) {
            const x = [];
            const y = [];
            for (let i = 0; i < n; i++) {
                x.push(mean + Math.random() * std * 2 - std); // Approximation
                y.push(mean + Math.random() * std * 2 - std);
            }
            return {x, y};
        }

        function generateData() {
            const N = 20;
            // Class 1 (around 0, 5) & Class 0 (around 5, 0) based on notebook logic somewhat
            // The notebook creates two clusters. Let's replicate visual.
            // Notebook logic: class1 = [random0, random5], class2 = [random5, random0]
            
            // Generate random0 (mean 0) and random5 (mean 5)
            const random0_x = Array.from({length: 10}, () => (Math.random()-0.5)*3); // mean 0
            const random0_y = Array.from({length: 10}, () => (Math.random()-0.5)*3); 
            
            const random5_x = Array.from({length: 10}, () => (Math.random()-0.5)*3 + 5); // mean 5
            const random5_y = Array.from({length: 10}, () => (Math.random()-0.5)*3 + 5);

            // Class 1: x1 ~ 0, x2 ~ 5
            const c1_x = random0_x;
            const c1_y = random5_y;

            // Class 2: x1 ~ 5, x2 ~ 0
            const c2_x = random5_x;
            const c2_y = random0_y;

            const trace1 = {
                x: c1_x, y: c1_y,
                mode: 'markers', type: 'scatter',
                name: 'Class 1 (Blue)',
                marker: { size: 12, color: '#3b82f6', line: {color: 'white', width: 1} }
            };

            const trace2 = {
                x: c2_x, y: c2_y,
                mode: 'markers', type: 'scatter',
                name: 'Class 0 (Red)',
                marker: { size: 12, color: '#ef4444', line: {color: 'white', width: 1} }
            };

            const layout = {
                title: 'ìƒì„±ëœ ë°ì´í„° ë¶„í¬',
                paper_bgcolor: 'rgba(0,0,0,0)',
                plot_bgcolor: 'rgba(0,0,0,0)',
                font: { color: '#e2e8f0' },
                xaxis: { title: 'x1', gridcolor: '#334155' },
                yaxis: { title: 'x2', gridcolor: '#334155' },
                legend: { x: 0, y: 1 },
                margin: { t: 40, r: 20, l: 40, b: 40 }
            };

            Plotly.newPlot('dataPlot', [trace1, trace2], layout, {displayModeBar: false});
            
            // Also update Step 4 visualization data source implicitly if needed, 
            // but for simplicity we keep Step 4 static or separate.
        }

        // Initial Data Gen
        generateData();


        // --- 4. Step 3: Training Simulation ---
        let isTraining = false;
        
        function simulateTraining() {
            if (isTraining) return;
            isTraining = true;
            document.getElementById('trainBtn').textContent = "í•™ìŠµ ì¤‘... (Training)";
            document.getElementById('trainBtn').classList.add('opacity-50', 'cursor-not-allowed');

            const epochs = 100;
            const lossData = [];
            const epochData = [];
            let currentLoss = 0.8; // Starting high

            // Setup Plot
            const layout = {
                title: 'Training Loss History',
                paper_bgcolor: 'rgba(0,0,0,0)',
                plot_bgcolor: 'rgba(0,0,0,0)',
                font: { color: '#e2e8f0' },
                xaxis: { title: 'Epoch', range: [0, epochs], gridcolor: '#334155' },
                yaxis: { title: 'Loss', range: [0, 1], gridcolor: '#334155' },
                margin: { t: 40, r: 20, l: 50, b: 40 }
            };
            Plotly.newPlot('lossPlot', [{x: [], y: [], mode: 'lines', line: {color: '#facc15', width: 3}}], layout, {displayModeBar: false});

            let ep = 0;
            const interval = setInterval(() => {
                ep++;
                // Simulate exponential decay loss
                currentLoss = currentLoss * 0.95 + (Math.random() * 0.01);
                if (currentLoss < 0.01) currentLoss = 0.01;

                lossData.push(currentLoss);
                epochData.push(ep);

                // Update UI
                document.getElementById('currentEpoch').innerText = ep;
                document.getElementById('currentLoss').innerText = currentLoss.toFixed(4);
                document.getElementById('progressBar').style.width = `${(ep/epochs)*100}%`;

                // Update Chart
                Plotly.extendTraces('lossPlot', {x: [[ep]], y: [[currentLoss]]}, [0]);

                // Update 3D Surface (Simulated learning effect)
                if (ep % 5 === 0) {
                    update3DSurface(ep);
                }

                if (ep >= epochs) {
                    clearInterval(interval);
                    isTraining = false;
                    document.getElementById('trainBtn').textContent = "ë‹¤ì‹œ í•™ìŠµí•˜ê¸° (Retrain)";
                    document.getElementById('trainBtn').classList.remove('opacity-50', 'cursor-not-allowed');
                }
            }, 30); // Speed of simulation
        }


        // --- 5. Step 4: 3D Surface Plot ---
        function sigmoid(z) {
            return 1 / (1 + Math.exp(-z));
        }

        function getZValue(x, y, epoch) {
            // Simulate decision boundary shifting
            // A simple plane that rotates to separate the clusters (0,5) and (5,0)
            // Ideal boundary is roughly x = y
            // Z = sigmoid(w1*x + w2*y + b)
            
            // Start with random bad weights
            let progress = Math.min(epoch / 100, 1);
            
            // Target weights roughly: w1=1, w2=-1 (to separate x=0,y=5 from x=5,y=0)
            // Or something that creates a high value at (0,5) and low at (5,0)
            // Let's say Class 1 (0,5) -> target 1, Class 0 (5,0) -> target 0.
            
            // Simulated learning curve for weights
            let w1 = -0.5 + (0.5 * progress);  // Start bad, go towards ?
            let w2 = 0.5 + (0.5 * progress);   // 
            // Actually let's just cheat visually:
            // Initial: Flat plane
            // Final: Sigmoid cliff separating (0,5) and (5,0)
            
            // Distance from ideal boundary line (y = x)
            // Class 1 (0,5) -> 5-0 = 5. Class 0 (5,0) -> 0-5 = -5.
            // So Z should be high when y-x is positive.
            
            let boundary_strength = 0.1 + (2.0 * progress); // Gets sharper
            let bias = 0;
            
            let val = (y - x) * boundary_strength + bias;
            return sigmoid(val);
        }

        function createSurfaceData(epoch = 100) {
            const size = 30;
            const x = [];
            const y = [];
            const z = [];
            
            for (let i = 0; i < size; i++) {
                const row_x = [];
                const row_y = [];
                const row_z = [];
                const x_val = -10 + (20 * i / (size - 1));
                
                for (let j = 0; j < size; j++) {
                    const y_val = -10 + (20 * j / (size - 1));
                    row_x.push(x_val);
                    row_y.push(y_val);
                    row_z.push(getZValue(x_val, y_val, epoch));
                }
                x.push(row_x);
                y.push(row_y);
                z.push(row_z);
            }
            return {x, y, z};
        }

        function init3DPlot() {
            const data = createSurfaceData(100);
            
            // Add scatter points for data
            // Class 1 (0, 5) - Blue - Target 1 (Top)
            const c1_x = [0, -1, 1, 0.5, -0.5];
            const c1_y = [5, 4, 6, 5.5, 4.5];
            const c1_z = [1, 1, 1, 1, 1]; // On top surface

            // Class 0 (5, 0) - Red - Target 0 (Bottom)
            const c0_x = [5, 4, 6, 5.5, 4.5];
            const c0_y = [0, -1, 1, 0.5, -0.5];
            const c0_z = [0, 0, 0, 0, 0]; // On bottom

            const surface = {
                type: 'surface',
                x: data.x,
                y: data.y,
                z: data.z,
                colorscale: 'Viridis',
                opacity: 0.8,
                showscale: false
            };

            const scatter1 = {
                type: 'scatter3d',
                mode: 'markers',
                x: c1_x, y: c1_y, z: c1_z,
                marker: {color: '#3b82f6', size: 5},
                name: 'Class 1'
            };

            const scatter2 = {
                type: 'scatter3d',
                mode: 'markers',
                x: c0_x, y: c0_y, z: c0_z,
                marker: {color: '#ef4444', size: 5},
                name: 'Class 0'
            };

            const layout = {
                title: 'ëª¨ë¸ ì˜ˆì¸¡ í‘œë©´ (Decision Surface)',
                paper_bgcolor: 'rgba(0,0,0,0)',
                font: { color: '#e2e8f0' },
                margin: { t: 40, r: 0, l: 0, b: 0 },
                scene: {
                    xaxis: {title: 'x1'},
                    yaxis: {title: 'x2'},
                    zaxis: {title: 'Prob (y_hat)'},
                    camera: {eye: {x: 1.5, y: 1.5, z: 1.2}}
                }
            };

            Plotly.newPlot('resultPlot', [surface, scatter1, scatter2], layout, {displayModeBar: false});
        }

        function update3DSurface(epoch) {
            const data = createSurfaceData(epoch);
            // Updating only the surface (trace 0)
            Plotly.animate('resultPlot', {
                data: [{z: data.z}],
                traces: [0],
                layout: {}
            }, {
                transition: {duration: 0},
                frame: {duration: 0, redraw: true}
            });
        }

        init3DPlot();

    </script>
</body>
</html>